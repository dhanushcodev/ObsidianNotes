#### User Model changes:

Adding review_user to Review model and throw validation error if same user tries to add new review

models.py:

```python
from django.db import models
from django.core.validators import MinValueValidator, MaxValueValidator
from django.contrib.auth.models import User
    
class Review(models.Model):
    review_user = models.ForeignKey('auth.User', on_delete=models.CASCADE)
    rating = models.PositiveIntegerField(validators=[MinValueValidator(1), MaxValueValidator(5)])
    description = models.TextField(blank=True)
    watchlist = models.ForeignKey(WatchList, on_delete=models.CASCADE, related_name='reviews')
    active = models.BooleanField(default=True)
    created = models.DateTimeField(auto_now_add=True)
    updated = models.DateTimeField(auto_now=True)
    
    def __str__(self):
        return str(self.rating) + " | " + self.watchlist.title
```

serializer.py:

```python
from rest_framework import serializers
from watchlist_app.models import WatchList, StreamPlatform, Review

class ReviewSerializer(serializers.ModelSerializer):
    review_user = serializers.StringRelatedField(read_only=True)
    class Meta:
        model = Review
        # fields = '__all__'
        exclude = ('watchlist',)
```

views.py:

```python
class ReviewCreate(generics.CreateAPIView):
    serializer_class = ReviewSerializer
    queryset = Review.objects.all()
    def perform_create(self, serializer):
        pk = self.kwargs.get('pk')
        watchlist = WatchList.objects.get(pk=pk)
        
        review_user = self.request.user
        if Review.objects.filter(watchlist=watchlist, review_user=review_user).exists():
            raise ValidationError("You have already reviewed this watchlist!")
        serializer.save(watchlist=watchlist, review_user=review_user)
```

#### Temporary Login and Logout:

create users in django admin panel

watchmate/urls.py:
```python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('watch/', include('watchlist_app.api.urls')),
    path('api-auth/', include('rest_framework.urls ')),
]
```
#### Basic Permissions:

- With permission we can add restriction to views from accessing it.
- Only authenticated user can access the views.

|Name|Framework|Purpose|
|---|---|---|
|`is_authenticated`|Django|Check if user is logged in|
|`IsAuthenticated`|DRF|API access only for logged-in users|
|`IsAdminUser`|DRF|API access only for admin/staff users|
|`AllowAny`|DRF|Anyone can access|
|`IsAuthenticatedOrReadOnly`|DRF|Logged-in users can edit; others can only read|

settings.py:

```python
REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ]
}
```
This will apply to all the views

 
#### Object level permission:

views.py:

```python
from rest_framework.permissions import IsAuthenticated, IsAuthenticatedOrReadOnly


class ReviewList(generics.ListCreateAPIView):
    serializer_class = ReviewSerializer
    permission_classes = [IsAuthenticated]
    
    def get_queryset(self): 
        pk = self.kwargs.get('pk')
        return Review.objects.filter(watchlist=pk)

class ReviewDetail(generics.RetrieveUpdateDestroyAPIView):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer
    permission_classes = [IsAuthenticatedOrReadOnly] 
```


#### Custom Permission:

Only the review user can delete or edit the review

permissions.py:

```python
# Import base permission class from Django REST Framework
from rest_framework import permissions

# Custom permission class that allows only admins to edit data,
# but lets everyone read (GET, HEAD, OPTIONS)
class IsAdminOrReadOnly(permissions.IsAdminUser):
    
    # This method decides whether the user has permission to access the view
    def has_permission(self, request, view):
        
        # Check if the user is an admin using the parent class (IsAdminUser)
        is_admin = super().has_permission(request, view)
        
        # If the request method is safe (read-only: GET, HEAD, OPTIONS),
        # allow access to everyone
        if request.method in permissions.SAFE_METHODS:
            return True
        
        # Otherwise (for write methods like POST, PUT, DELETE),
        # only allow if the user is admin
        return is_admin
        
class IsReviewAuthorOrReadOnly(permissions.BasePermission):
    def has_object_permission(self, request, view, obj):
        if request.method in permissions.SAFE_METHODS:
            return True
        return obj.review_user == request.user

```

views.py:

```python
from watchlist_app.api.permissions import IsAdminOrReadOnly,IsReviewAuthorOrReadOnly

class ReviewDetail(generics.RetrieveUpdateDestroyAPIView):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer
    permission_classes = [IsReviewAuthorOrReadOnly]
```

