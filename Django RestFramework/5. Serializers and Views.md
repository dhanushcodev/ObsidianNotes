Created a separate api folder

#### Serializers GET request:

api/urls.py:
```python
from django.urls import path, include
from watchlist_app.api import views
urlpatterns = [
    path('list/', views.movie_list, name='movie-list'),
    path('<int:pk>/', views.movie_details, name='movie-details')
]
```

watchmate/urls.py:
```python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('movie/', include('watchlist_app.api.urls')),
]
```

api/serializer.py:
```python
from rest_framework import serializers
from watchlist_app.models import Movie

class MovieSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    name = serializers.CharField(max_length=100)
    description = serializers.CharField(max_length=255)
    active = serializers.BooleanField()
```

api/views.py:
```python
from watchlist_app.models import Movie
from watchlist_app.api.serializer import MovieSerializer
from rest_framework.response import Response
from rest_framework.decorators import api_view

@api_view(['GET'])
def movie_list(request):
    movies = Movie.objects.all()
    serializer = MovieSerializer(movies, many=True) #many=True for multiple objects
    return Response(serializer.data)

@api_view(['GET'])
def movie_details(request, pk):
    movie = Movie.objects.get(pk=pk)
    serializer = MovieSerializer(movie)
    return Response(serializer.data)
```

#### Serializers POST, PUT, DELETE:

api/views.py:
```python
from watchlist_app.models import Movie
from watchlist_app.api.serializer import MovieSerializer
from rest_framework.response import Response
from rest_framework.decorators import api_view

@api_view(['GET','POST'])  
def movie_list(request):
    if request.method == 'GET':
        movies = Movie.objects.all()
        serializer = MovieSerializer(movies, many=True) #many=True for multiple objects
        return Response(serializer.data)
    elif request.method == 'POST':
        serializer = MovieSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        else:
            return Response(serializer.errors)

@api_view(['GET','PUT','DELETE'])
def movie_details(request, pk):

    if request.method == 'GET':
        movie = Movie.objects.get(pk=pk)
        serializer = MovieSerializer(movie)
        return Response(serializer.data)
        
    elif request.method == 'PUT':
        movie = Movie.objects.get(pk=pk)
        serializer = MovieSerializer(movie, data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        else:
            return Response(serializer.errors)
            
    elif request.method == 'DELETE':
        movie = Movie.objects.get(pk=pk)
        movie.delete()
        return Response({'message': 'Movie deleted successfully!'})
```

api/serializer.py:
```python
from rest_framework import serializers
from watchlist_app.models import Movie

class MovieSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    name = serializers.CharField(max_length=100)
    description = serializers.CharField(max_length=255)
    active = serializers.BooleanField()
    
    def create(self, validated_data):
        return Movie.objects.create(**validated_data)
    
    def update(self, instance, validated_data):
        instance.name = validated_data.get('name', instance.name)
        instance.description = validated_data.get('description', instance.description)
        instance.active = validated_data.get('active', instance.active)
        instance.save()
        return instance
```


#### Status codes:
```python
from watchlist_app.models import Movie
from watchlist_app.api.serializer import MovieSerializer
from rest_framework.response import Response
from rest_framework.decorators import api_view
from rest_framework import status

@api_view(['GET','POST'])  
def movie_list(request):
    if request.method == 'GET':
        try:
            movies = Movie.objects.all()
        except Movie.DoesNotExist:
            return Response(data={'message': 'No movies found!'},status=status.HTTP_404_NOT_FOUND)
        serializer = MovieSerializer(movies, many=True) #many=True for multiple objects
        return Response(serializer.data,status=status.HTTP_200_OK)
    elif request.method == 'POST':
        serializer = MovieSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        else:
            return Response(serializer.errors)

@api_view(['GET','PUT','DELETE'])
def movie_details(request, pk):
    if request.method == 'GET':
        try:
            movie = Movie.objects.get(pk=pk)
        except Movie.DoesNotExist:
            return Response(data={'message': 'Movie not found!'},status=status.HTTP_404_NOT_FOUND)
        serializer = MovieSerializer(movie)
        return Response(serializer.data)
    elif request.method == 'PUT':
        try:
            movie = Movie.objects.get(pk=pk)
        except Movie.DoesNotExist:
            return Response(data={'message': 'Movie not found!'},status=status.HTTP_404_NOT_FOUND)
        serializer = MovieSerializer(movie, data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        else:
            return Response(serializer.errors)
    elif request.method == 'DELETE':
        try:
            movie = Movie.objects.get(pk=pk)
        except Movie.DoesNotExist:
            return Response(data={'message': 'Movie not found!'},status=status.HTTP_404_NOT_FOUND)
        movie.delete()
        return Response(data={'message': 'Movie deleted successfully!'},status=status.HTTP_204_NO_CONTENT)
```

#### APIView Class:

api/views.py:
```python
from watchlist_app.models import Movie
from watchlist_app.api.serializer import MovieSerializer
from rest_framework.response import Response
from rest_framework import status
from rest_framework.views import APIView

class MovieListAV(APIView):
    def get(self, request):
        movies = Movie.objects.all()
        serializer = MovieSerializer(movies, many=True)
        return Response(serializer.data)
    
    def post(self, request):
        serializer = MovieSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
class MovieDetailAV(APIView):
    def get_object(self, pk):
        try:
            return Movie.objects.get(pk=pk)
        except Movie.DoesNotExist:
            return None
    
    def get(self, request, pk):
        movie = self.get_object(pk)
        if movie is None:
            return Response(data={'message': 'Movie not found!'}, status=status.HTTP_404_NOT_FOUND)
        serializer = MovieSerializer(movie)
        return Response(serializer.data)
    
    def put(self, request, pk):
        movie = self.get_object(pk)
        if movie is None:
            return Response(data={'message': 'Movie not found!'}, status=status.HTTP_404_NOT_FOUND)
        serializer = MovieSerializer(movie, data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
    def delete(self, request, pk):
        movie = self.get_object(pk)
        if movie is None:
            return Response(data={'message': 'Movie not found!'}, status=status.HTTP_404_NOT_FOUND)
        movie.delete()
        return Response(data={'message': 'Movie deleted successfully!'}, status=status.HTTP_204_NO_CONTENT)
```

api/urls:
```python
from django.urls import path
from watchlist_app.api import views
urlpatterns = [
    path('list/', views.MovieListAV.as_view(), name='movie-list'),
    path('<int:pk>/', views.MovieDetailAV.as_view(), name='movie-details')
]
```

#### Validations:

api/serializer.py:
```python
from rest_framework import serializers
from watchlist_app.models import Movie

#validator functions
def name_length(value):
    if len(value) < 2:
        raise serializers.ValidationError("Name is too short!")
    elif len(value) > 30:
        raise serializers.ValidationError("Name is too long!")
    return value

class MovieSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    name = serializers.CharField(validators=[name_length])#validator function
    description = serializers.CharField(max_length=255)
    active = serializers.BooleanField()
    
    def create(self, validated_data):
        return Movie.objects.create(**validated_data)
    
    def update(self, instance, validated_data):
        instance.name = validated_data.get('name', instance.name)
        instance.description = validated_data.get('description', instance.description)
        instance.active = validated_data.get('active', instance.active)
        instance.save()
        return instance
    
    #Field-level validation
    def validate_name(self, value):
        if len(value) < 2:
            raise serializers.ValidationError("Name is too short!")
        elif len(value) > 30:
            raise serializers.ValidationError("Name is too long!")
        return value

    #object-level validation
    def validate(self, data):
        if data['name'] == data['description']:
            raise serializers.ValidationError("Name and Description should be different!")
        return data
```

#### Model Serializer:

api/serializer.py:
```python
from rest_framework import serializers
from watchlist_app.models import Movie

class MovieSerializer(serializers.ModelSerializer):
    class Meta:
        model = Movie
        fields = ['name', 'description'] # '__all__' for all fields 
    
    def validate_name(self, value):
        if len(value) < 2:
            raise serializers.ValidationError("Name is too short!")
        return value
    
    def validate(self, data):
        if data['name'] == data['description']:
            raise serializers.ValidationError("Name and Description should be different!")
        return data
```

#### Custom Serializer Fields:

api/serializer.py:
```python
class MovieSerializer(serializers.ModelSerializer):
    
    len_name = serializers.SerializerMethodField() # to add custom field
    
    class Meta:
        model = Movie
        fields = ['name', 'description','len_name'] # include custom field here or use '__all__' for all fields
        
    def get_len_name(self, object):
        return len(object.name)
```

#### New Models:

run makemigrations and migrate cmd every time we create a new model
also run createsuperuser cmd after new model so that we can access and edit table data

api/models.py:
```python
from django.db import models

class WatchList(models.Model):
    title = models.CharField(max_length=30)
    storyline = models.TextField()
    active = models.BooleanField(default=True)
    created = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.title
    
class StreamPlatform(models.Model):
    name = models.CharField(max_length=30)
    about = models.TextField()
    website = models.URLField()

    def __str__(self):
        return self.name
```

api/serializer.py:
```python
from rest_framework import serializers
from watchlist_app.models import WatchList, StreamPlatform

class WatchlistSerializer(serializers.ModelSerializer):
    
    class Meta:
        model = WatchList
        fields = '__all__'

class StreamPlatformSerializer(serializers.ModelSerializer):
    
    class Meta:
        model = StreamPlatform
        fields = '__all__'
```

api/views.py:
```python
from watchlist_app.models import WatchList, StreamPlatform
from watchlist_app.api.serializer import WatchlistSerializer, StreamPlatformSerializer
from rest_framework.response import Response
from rest_framework import status
from rest_framework.views import APIView

class WatchListAV(APIView):
    def get(self, request):
        movies = WatchList.objects.all()
        serializer = WatchlistSerializer(movies, many=True)
        return Response(serializer.data)
    
    def post(self, request):
        serializer = WatchlistSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
class WatchDetailAV(APIView):
    def get_object(self, pk):
        try:
            return WatchList.objects.get(pk=pk)
        except WatchList.DoesNotExist:
            return None
    
    def get(self, request, pk):
        movie = self.get_object(pk)
        if movie is None:
            return Response(data={'message': 'Movie not found!'}, status=status.HTTP_404_NOT_FOUND)
        serializer = WatchlistSerializer(movie)
        return Response(serializer.data)
    
    def put(self, request, pk):
        movie = self.get_object(pk)
        if movie is None:
            return Response(data={'message': 'Movie not found!'}, status=status.HTTP_404_NOT_FOUND)
        serializer = WatchlistSerializer(movie, data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
    def delete(self, request, pk):
        movie = self.get_object(pk)
        if movie is None:
            return Response(data={'message': 'Movie not found!'}, status=status.HTTP_404_NOT_FOUND)
        movie.delete()
        return Response(data={'message': 'Movie deleted successfully!'}, status=status.HTTP_204_NO_CONTENT)

class StreamPlatformAV(APIView):
    def get(self, request):
        platforms = StreamPlatform.objects.all()
        serializer = StreamPlatformSerializer(platforms, many=True)
        return Response(serializer.data)
    
    def post(self, request):
        serializer = StreamPlatformSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
```

#### Django Relationships:

Example for one to many relationship, stream platform can have many movies, but one movie can be streamed in only one patform.
when any of the row in streamPlatfrom is deleted the corresponding watchlist row/rows which had mapped to that id of the streamPlatform row is also deleted

api/models.py:
```python
from django.db import models

class StreamPlatform(models.Model):
    name = models.CharField(max_length=30)
    about = models.TextField()
    website = models.URLField()

    def __str__(self):
        return self.name

class WatchList(models.Model):
    title = models.CharField(max_length=30)
    storyline = models.TextField()
    platform = models.ForeignKey(StreamPlatform, on_delete=models.CASCADE, related_name='watchlists')
    active = models.BooleanField(default=True)
    created = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.title
```

#### Nested Serializers:

```python
from rest_framework import serializers
from watchlist_app.models import WatchList, StreamPlatform

class WatchlistSerializer(serializers.ModelSerializer):
    
    class Meta:
        model = WatchList
        fields = '__all__'

class StreamPlatformSerializer(serializers.ModelSerializer):
    #new field which has list of all the watchlist in this stream platform
    watchlists = WatchlistSerializer(many=True, read_only=True)
    
    class Meta:
        model = StreamPlatform
        fields = '__all__'
```

#### Serializers Relation:

api/serializer.py:
```python
from rest_framework import serializers
from watchlist_app.models import WatchList, StreamPlatform

class WatchlistSerializer(serializers.ModelSerializer):
    
    class Meta:
        model = WatchList
        fields = '__all__'

class StreamPlatformSerializer(serializers.ModelSerializer):
    
    # watchlists = WatchlistSerializer(many=True, read_only=True)
    watchlists = serializers.StringRelatedField(many=True)
    
    class Meta:
        model = StreamPlatform
        fields = '__all__'
```

string related field shows the `__str__` from the model in the new watchlists field

output:
```json
[
    {
        "id": 1,
        "watchlists": [
            "OG"
        ],
        "name": "Netflix",
        "about": "A Netflix company",
        "website": "[https://www.netflix.com](https://www.netflix.com/)"
    },
    {
        "id": 2,
        "watchlists": [
            "Kantara part 1"
        ],
        "name": "Amazon prime",
        "about": "A amazon company",
        "website": "[https://www.prime.com](https://www.prime.com/)"
    }
]
```

#### GenericAPIView and Mixins:

new model Review

api/models.py:
```python
from django.db import models
from django.core.validators import MinValueValidator, MaxValueValidator

class StreamPlatform(models.Model):
    name = models.CharField(max_length=30)
    about = models.TextField()
    website = models.URLField()

    def __str__(self):
        return self.name

class WatchList(models.Model):
    title = models.CharField(max_length=30)
    storyline = models.TextField()
    platform = models.ForeignKey(StreamPlatform, on_delete=models.CASCADE, related_name='watchlists')
    active = models.BooleanField(default=True)
    created = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.title
    
class Review(models.Model):
    rating = models.PositiveIntegerField(validators=[MinValueValidator(1), MaxValueValidator(5)])
    description = models.TextField(blank=True)
    watchlist = models.ForeignKey(WatchList, on_delete=models.CASCADE, related_name='reviews')
    active = models.BooleanField(default=True)
    created = models.DateTimeField(auto_now_add=True)
    updated = models.DateTimeField(auto_now=True)
    
    def __str__(self):
        return str(self.rating) + " | " + self.watchlist.title
```

new serializer ReivewSerializer

api/serializer.py:
```python
from rest_framework import serializers
from watchlist_app.models import WatchList, StreamPlatform, Review

class ReviewSerializer(serializers.ModelSerializer):
    
    class Meta:
        model = Review
        fields = '__all__'

class WatchlistSerializer(serializers.ModelSerializer):
    reviews = ReviewSerializer(many=True, read_only=True)
    class Meta:
        model = WatchList
        fields = '__all__'

class StreamPlatformSerializer(serializers.ModelSerializer):
    
    # watchlists = WatchlistSerializer(many=True, read_only=True)
    watchlists = serializers.StringRelatedField(many=True)
    
    class Meta:
        model = StreamPlatform
        fields = '__all__'
```

views defined using GenericAPIView and Mixins
- ListModelMixin
- CreateModelMixin
- RetriveModelMixin
- UpdateModelMixin
- DestroyModelMixin
name says the purpose

api/views.py:
```python
from rest_framework import generics, mixins

class ReviewList(generics.GenericAPIView, mixins.ListModelMixin, mixins.CreateModelMixin):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer

    def get(self, request):
        return self.list(request)

    def post(self, request):
        return self.create(request)

class ReviewDetail(generics.GenericAPIView, mixins.RetrieveModelMixin):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer

    def get(self, request, pk):
        return self.retrieve(request, pk)
```

api/urls.py:
```python
path('review', views.ReviewList.as_view(), name='review-list'),
path('review/<int:pk>', views.ReviewDetail.as_view(), name='review-details'),
```
#### Concrete View Classes:

- ListAPIView
- RetrieveAPIView
- DestroyAPIView
- UpdateAPIView
- ListCreateAPIView
- RetrieveUpdateAPIView
- RetrieveDestroyAPIView
- RetrieveUpdateDestroyAPIView
names say the purpose

api/views.py:
```python
class ReviewList(generics.ListCreateAPIView):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer

class ReviewDetail(generics.RetrieveUpdateDestroyAPIView):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer
```

#### Overwrite queryset:

```python

```