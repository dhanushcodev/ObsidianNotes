## ğŸ¯ Goal: Find GCD (Greatest Common Divisor)

Letâ€™s say we want the **GCD of 48 and 18**.

We ask:

> What is the biggest number that divides both **48** and **18**?

---

## ğŸ”¢ Why Use `%` (Modulus)?

The **modulus operator** gives us the **remainder** after dividing.

For example:

`48 % 18 = 12 (because 18 goes into 48 two times, with a remainder of 12)`

---

## ğŸ¤¯ Core Mathematical Idea Behind Euclidean Method:

> If `a` and `b` are two numbers, then  
> **GCD(a, b) = GCD(b, a % b)**  
> (Keep doing this until `b` becomes 0)

### WHY does this work?

Letâ€™s go step-by-step with **real numbers**:

#### Step 1:


`GCD(48, 18) â†’ 48 divided by 18 leaves remainder 12 â†’ So GCD(48, 18) = GCD(18, 12)`

#### Step 2:


`GCD(18, 12) â†’ 18 divided by 12 leaves remainder 6 â†’ So GCD(18, 12) = GCD(12, 6)`

#### Step 3:


`GCD(12, 6) â†’ 12 divided by 6 leaves remainder 0 â†’ So GCD(12, 6) = GCD(6, 0)`

At this point, remainder is 0. So we stop.

ğŸ‰ Final Answer: GCD = 6

---

## ğŸ§  Why is this true mathematically?

Letâ€™s say:

`a = b * q + r`

This is how normal division works:

> Dividend = Divisor Ã— Quotient + Remainder  
> 48 = 18 Ã— 2 + 12

Now:  
ğŸ‘‰ Any number that divides both `a` and `b` will also divide `r`.

So instead of checking GCD of (a, b), we can check GCD of (b, r).  
This saves work!

This is **why** we keep doing:

`GCD(a, b) â†’ GCD(b, a % b)`

---

## ğŸ§‘â€ğŸ’» Code


```java
public static int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
```

### Each loop does:

- `a % b` â†’ Find remainder
    
- Then shift:
    
    - Old `b` becomes new `a`
        
    - Remainder becomes new `b`
        
- Repeat until remainder becomes `0`
    
- Then return the last non-zero value â†’ that's the **GCD**
    

---

## ğŸŸ¢ Final Simple Example

mathematica

CopyEdit

`GCD(100, 75) â†’ 100 % 75 = 25 â†’ GCD(75, 25) â†’ 75 % 25 = 0 â†’ GCD(25, 0) âœ… GCD is 25`